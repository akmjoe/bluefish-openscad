<?xml version="1.0"?>
<!--
		Bluefish HTML Editor
		openSCAD.bflang2 $Revision: 1 $
		
		@author akmjoe

	    This program is free software: you can redistribute it and/or modify
		it under the terms of the GNU General Public License as published by
		the Free Software Foundation, either version 3 of the License, or
		(at your option) any later version.

		This program is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		GNU General Public License for more details.

		You should have received a copy of the GNU General Public License
		along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<bflang name="OpenSCAD" version="2.0" table="1438" contexts="1" matches="439">
<header>
	<mime type="application/x-openscad"/>
	<mime type="text/x-openscad" />
	<option name="show_in_menu" default="1"/>
	<option name="load_reference" default="1" />
	<option name="load_completion" default="1" />
	<option name="C style comment_foldable" default="1" description="Allow folding of C style comments" />
	<option name="Parentheses block_foldable" default="0" description="Allow folding of the Parentheses block" />
	<option name="Square brackets block_foldable" default="0" description="Allow folding of Square brackets block"/>
	<option name="Curly brackets block_foldable" default="1" description="Allow folding of Curly brackets block"/>
	<option name="autocomplete_with_arguments" default="1" />
	<option name="autocomplete_with_parentheses" default="0" />
	<option name="append_braces" default="1" description="Automatically add semicolon"/>
	<option name="append_semicolon" default="1" description="Automatically add curly braces"/>
	<highlight name="attribute" style="attribute"  />
	<highlight name="brackets" style="brackets"  />
	<highlight name="comment" style="comment"  />
	<highlight name="definition" style="special-tag"  />
	<highlight name="import" style="special-tag2"  />
	<highlight name="join" style="tag"  />
	<highlight name="keyword" style="keyword"  />
	<highlight name="func" style="special-keyword"  />
	<highlight name="math" style="special-keyword"  />
	<highlight name="operator" style="operator"  />
	<highlight name="paren" style="brackets"  />
	<highlight name="primitive" style="function"  />
	<highlight name="special-variable" style="special-attribute"  />
	<highlight name="string" style="string"  />
	<highlight name="transform" style="special-function"  />
	<highlight name="user_function" style="special-keyword"  />
	<highlight name="value" style="value"  />
	<highlight name="boolean" style="string" />
<!-- line modifiers -->
	<highlight name="highlight" style="preprocessor"  />
	<highlight name="disable" style="comment"  />
	<highlight name="only" style="special-warning"  />
	<highlight name="transparent" style="warning"  />
</header>
<properties>
	<!-- <comment type="block" start="=start" end="=end" /> -->
	<comment type="block" start="/*" end="*/" />
	<comment type="line" start="//" />
	<smartindent characters="{([" />
	<smartoutdent characters="})]" />
</properties>
<definition>
<context symbols=" ;(){}[]:\&#34;\\',&gt;&lt;*&amp;^%!+=-|/?#&#9;&#10;&#13;">
<!-- The following must be defined early so it can be referenced in shapes-->
<!-- Number & boolean values -->
<group  highlight="value">
<!-- Numbers -->
	<element pattern="[0-9]*\.[0-9]+" is_regex="1" id="dec" />
	<element pattern="[0-9]+" is_regex="1" id="num" />
</group>
<group highlight="boolean">
	<autocomplete enable="1" />
<!-- Boolean -->
	<element pattern="true" id="true" />
	<element pattern="false" id="false" />
</group>
<element pattern="&lt;" highlight="string" id="string">
	<context symbols="\&gt; \=&#13;&#10;" highlight="string">
		<element pattern="\\." is_regex="1" highlight="string"/>
		<element pattern="&gt;" highlight="string" ends_context="1" />
		<element pattern="[&#13;&#10; =]" is_regex="1" ends_context="1" />
	</context>
</element>

<element pattern="&#34;" highlight="string" id="string">
	<context symbols="\&#34;" highlight="string">
		<element pattern="\\." is_regex="1" highlight="string"/>
		<element pattern="&#34;" highlight="string" ends_context="1" />
	</context>
</element>


<element id="e.lbrace" pattern="{" starts_block="1" highlight="brackets" block_name="Curly brackets block">
	<autocomplete enable="1" append="}" backup_cursor="1" />
</element>
<element pattern="}" ends_block="1" blockstartelement="e.lbrace" highlight="brackets" />
<element id="e.lbracket" pattern="[" starts_block="1" highlight="brackets">
	<autocomplete enable="1" append="]" backup_cursor="1" />
</element>
<element id="e.rbracket" pattern="]" ends_block="1" blockstartelement="e.lbracket" highlight="brackets" />
<element id="e.lparen" pattern="(" starts_block="1" highlight="paren" block_name="Parentheses block">
	<autocomplete enable="1" append=")" backup_cursor="1" />
</element>
<element id="e.rparen" pattern=")" ends_block="1" blockstartelement="e.lparen" highlight="paren" />


<element id="center" pattern="center" highlight="attribute">
	<autocomplete enable="1" />
	<reference>(boolean) 0,0,0 is center (default is corner for cube,square; cylinder is already centered on x,y; this only changes z)</reference>
	<context symbols=" \=),">
		<element pattern="true" highlight="boolean" ends_context="1"><autocomplete enable="1" /></element>
		<element pattern="false" highlight="boolean" ends_context="1"><autocomplete enable="1" /></element>
	</context>
</element>
<context id="functions" symbols="([],\=&#10;&#13;:\*\+\-\/ )">
	<element idref="num"  />
	<element idref="dec" />
	<element idref="string" />
	<element idref="e.lbracket" />
	<element idref="e.rbracket" />
	<element id="l.paren" pattern="(" highlight="paren" starts_block="1" />
	<element id="r.paren" pattern=")" ends_context="1" highlight="paren" ends_block="1" blockstartelement="l.paren" />

	<group  highlight="math">
		<autocomplete enable="1" append="()" backup_cursor="1" />
		<element pattern="abs" id="abs">
			<reference>Absolute value of a signed decimal (converts negative to positive)</reference>
			<context idref="functions" />
		</element>
		<element pattern="acos" id="acos">
			<reference>Arccosine, or inverse cossine (in degrees)</reference>
			<context idref="functions" />
		</element>
		<element pattern="asin" id="asin">
			<reference>Arcsine, or inverse sine (in degrees)</reference>
			<context idref="functions" />
		</element>
		<element pattern="atan" id="atan">
			<reference>Arctangent, or inverse tangent (in degrees)</reference>
			<context idref="functions" />
		</element>
		<element pattern="atan2" id="atan2">
			<reference>Two-argument atan function. Returns the principal value of the arc tangent of y/x, expressed in degrees.</reference>
			<context idref="functions" />
		</element>
		<element pattern="ceil" id="ceil">
			<reference>Rounds up to the next integer</reference>
			<context idref="functions" />
		</element>
		<element pattern="cos" id="cos">
			<reference>Cosine of angle (deggrees)</reference>
			<context idref="functions" />
		</element>
		<element pattern="exp" id="exp">
			<reference>Returns the base-e exponential function of x, which is the number e raised to the power x.</reference>
			<context idref="functions" />
		</element>
		<element pattern="floor" id="floor">
			<reference>Rounds down to the next integer.</reference>
			<context idref="functions" />
		</element>
		<element pattern="ln" id="ln">
			<reference>Natural Logarithm</reference>
			<context idref="functions" />
		</element>
		<element pattern="log" id="log">
			<reference></reference>
			<context idref="functions" />
		</element>
		<element pattern="sqrt" id="sqrt">
			<reference>Square Root</reference>
			<context idref="functions" />
		</element>
		<element pattern="tan" id="tan">
			<reference>Tangent of angle (degrees)</reference>
			<context idref="functions" />
		</element>
		<element pattern="sin" id="sin">
			<reference>Sine of angle (degrees)</reference>
			<context idref="functions" />
		</element>
		<element pattern="sign" id="sign">
			<reference>Signum function. Returns a unit value that extracts the sign of a value.</reference>
			<context idref="functions" />
		</element>
		<element pattern="round" id="round">
			<reference>Round up/down to next integer.</reference>
			<context idref="functions" />
		</element>
		<element pattern="rands" id="rands">
			<reference>Random number generator. Parameters: minimum value, maximum value, value count, seed value (optional)</reference>
			<context idref="functions" />
		</element>
		<element pattern="pow" id="pow">
			<reference>Mathematical power function. Parameters: base, exponent.</reference>
			<context idref="functions" />
		</element>
		<element pattern="min" id="min">
			<reference>Returns the minimum of the parameters. Parameters can be a list of numbers or a vector.</reference>
			<context idref="functions" />
		</element>
		<element pattern="max" id="max">
			<reference>Returns the maximum of the parameters. Parameters can be a list of numbers or a vector.</reference>
			<context idref="functions" />
		</element>
		<element pattern="len" id="len">
			<reference>Returns the length of an array, vector or string.</reference>
			<context idref="functions" />
		</element>
	</group>
	
	<!-- Other builtin functions -->
	<group highlight="func">
		<autocomplete enable="1" append="()" backup_cursor="1" />
		<element pattern="str" id="str">
			<reference>Convert all arguments to strings and concatenate.</reference>
			<context idref="functions" />
		</element>
		<element pattern="concat" id="concat">
			<reference>Returns a vector containing all the arguments</reference>
			<context idref="functions" />
		</element>
		<element pattern="chr" id="chr">
			<reference>Unicode character</reference>
			<context idref="functions" />
		</element>
		<element pattern="search" id="search">
			<reference>The search() function is a general-purpose function to find one or more (or all) occurrences of a value or list of values in a vector, string or more complex list-of-list construct. </reference>
			<context idref="functions" />
		</element>
		<element pattern="version" id="version">
			<reference>Returns the OpenSCAD version as a vector, e.g. [2011, 09, 23]</reference>
			<context idref="functions" />
		</element>
		<element pattern="version_num" id="version_num">
			<reference>Returns the OpenSCAD version as a number, e.g. 20110923</reference>
			<context idref="functions" />
		</element>
		<element pattern="norm" id="norm">
			<reference>Returns the euclidean norm of a vector. Note this returns the actual numeric length while len returns the number of elements in the vector or array. </reference>
			<context idref="functions" />
		</element>
		<element pattern="cross" id="cross">
			<reference>Calculates the cross product of two vectors in 3D space. The result is a vector that is perpendicular to both of the input vectors.</reference>
			<context idref="functions" />
		</element>
		<element pattern="parent_module" id="parent_module">
			<reference></reference>
			<context idref="functions" />
		</element>
	</group>

</context>

<!-- End referenced elements-->
<!-- Import math keywords -->
<element idref="abs" />
<element idref="acos" />
<element idref="asin" />
<element idref="atan" />
<element idref="atan2" />
<element idref="ceil" />
<element idref="cos" />
<element idref="exp" />
<element idref="floor" />
<element idref="ln" />
<element idref="log" />
<element idref="sqrt" />
<element idref="tan" />
<element idref="sin" />
<element idref="sign" />
<element idref="round" />
<element idref="rands" />
<element idref="pow" />
<element idref="min" />
<element idref="max" />
<element idref="str" />
<element idref="len" />
<element idref="concat" />
<element idref="chr" />
<element idref="search" />
<element idref="version" />
<element idref="version_num" />
<element idref="norm" />
<element idref="cross" />
<element idref="parent_module" />
<!-- Shapes -->
<group  highlight="primitive">
<!-- 2d Shapes -->
<element pattern="square" highlight="primitive" >
	<reference><b>Create a (2d) square.&#13;Params:</b> size=[<i>width,height</i>](<i>as vectors</i>), center(<i>boolean</i>)&#13;<b>Alt. Params:</b> size=<i>value</i>, center</reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="size"><reference>Square size (number or vectors)&#13;For non-matching dimensions, use vectors: [<i>width,heght</i>]</reference></element>
			
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="e.lbracket" />
		<element idref="e.rbracket" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>

<element pattern="circle" highlight="primitive" >
	<reference><b>Create a (2d) circle.&#13;Params:</b> r=<i>radius</i>|d=<i>diameter</i>&#13;<b>Special Params:</b>$fn=<i>Number segments</i> | $fs=<i>segment size</i> | $fa=<i>segment angle(degrees)</i></reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="d"><reference>Diameter of circle</reference></element>
			<element pattern="r"><reference>Radius of circle</reference></element>
		</group>
		<group highlight="special-variable">
			<autocomplete enable="1" />
			<element pattern="$fn"><reference>Number of segments</reference></element>
			<element pattern="$fs"><reference>Segment size (in default units)</reference></element>
			<element pattern="$fa"><reference>Segment Angle (in degrees)</reference></element>
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>

<element pattern="polygon" highlight="primitive" >
	<reference>Create a (2d) polygon (generic shape).&#13;Params: points=[[<i>x1,y1</i>],[<i>x2,y2</i>],...], paths=[[<i>point1,point2,point3</i>],[<i>point1,point2,point4</i>],...], convexity=<i>integer</i></reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="points"><reference>Vector of points. Each point is in turn a vector, [<i>x,y</i>], of its coordinates.</reference></element>
			<element pattern="paths"><reference>Vector of the points specified in <i>points</i>. (See below) If ommitted, uses all points in order.&#13;<b>Single vector:</b> The order to traverse the points. Uses indices from 0 to n-1. May be in a different order and use all or part, of the points listed.&#13;<b>Multiple vectors</b> Creates primary and secondary shapes. Secondary shapes are subtracted from the primary shape (like difference). Secondary shapes may be wholly or partially within the primary shape.</reference></element>
			<element pattern="convexity"><reference>Integer number of "inward" curves, ie. expected path crossings of an arbitrary line through the polygon</reference></element>
			
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="e.lbracket" />
		<element idref="e.rbracket" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>

<element pattern="text" highlight="primitive" >
	<reference><b>Create a (2d) text.&#13;Params:</b> text=<i>text string</i>, size=<i>height(approx)</i>, font=<i>font face</i>, halign, valign, spacing, direction, language, script&#13;<b>Special Params:</b>$fn</reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="text"><reference>Text to draw</reference></element>
			<element pattern="size"><reference>Text height (approx)</reference></element>
			<element pattern="font"><reference>Font name &amp; style. Eg, &quot;Liberation Sans:style=Bold Italic&quot;</reference></element>
			<element pattern="valign">
				<reference>String. The vertical alignment for the text. Possible values are <i>top</i>, <i>center</i>, <i>baseline</i> and <i>bottom</i>. Default is <i>baseline</i>.</reference>
				<context symbols="\=,) ">
					<element pattern="&#34;" highlight="string"></element>
					<element pattern="&#34;top&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
					<element pattern="&#34;center&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
					<element pattern="&#34;baseline&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
					<element pattern="&#34;bottom&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
				</context>
			</element>
			<element pattern="halign">
				<reference>String. The horizontal alignment for the text. Possible values are <i>left</i>, <i>center</i> and <i>right</i>. Default is <i>left</i>.</reference>
				<context symbols="\=,) ">
					<element pattern="&#34;" highlight="string"></element>
					<element pattern="&#34;left&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
					<element pattern="&#34;center&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
					<element pattern="&#34;right&#34;" highlight="string" ends_context="1"><autocomplete enable="1" /></element>
				</context>
			</element>
			<element pattern="spacing"><reference>Decimal. Factor to increase/decrease the character spacing.</reference></element>
			<element pattern="direction">
				<reference>String. Direction of the text flow. Possible values are <i>ltr</i> (left-to-right), <i>rtl</i> (right-to-left), <i>ttb</i> (top-to-bottom) and <i>btt</i> (bottom-to-top). Default is <i>ltr</i>.</reference>
				<context symbols="\=,) ">
					<element pattern="&#34;" highlight="string"></element>
					<element pattern="&#34;ltr&#34;" highlight="string" ends_context="1"><reference>Left to Right</reference><autocomplete enable="1" /></element>
					<element pattern="&#34;rtl&#34;" highlight="string" ends_context="1"><reference>Right to Left</reference><autocomplete enable="1" /></element>
					<element pattern="&#34;ttb&#34;" highlight="string" ends_context="1"><reference>Top to Bottom</reference><autocomplete enable="1" /></element>
					<element pattern="&#34;btt&#34;" highlight="string" ends_context="1"><reference>Bottom to Top</reference><autocomplete enable="1" /></element>
				</context>
			</element>
			<element pattern="language"><reference>String. The language of the text. Default is <i>en</i>.</reference></element>
			<element pattern="script"><reference>String. The script of the text. Default is <i>latin</i>.</reference></element>
		</group>
		<group highlight="special-variable">
			<autocomplete enable="1" />
			<element pattern="$fn"><reference>Used for subdividing the curved path segments provided by freetype</reference></element>
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>
<!-- 3d Shapes-->
<element pattern="sphere" highlight="primitive" >
	<reference><b>Create a (3d) sphere.&#13;Params:</b> radius | d=<i>diameter</i>&#13;<b>Special Params:</b>$fn=<i>Number segments</i> | $fs=<i>segment size</i> | $fa=<i>segment angle(degrees)</i></reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element pattern="r"><reference>Sphere Radius</reference></element>
			<element pattern="d"><reference>Sphere Diameter</reference></element>
		</group>
		<group highlight="special-variable">
			<autocomplete enable="1" />
			<element pattern="$fn"><reference>Number of segments</reference></element>
			<element pattern="$fs"><reference>Segment size (in default units)</reference></element>
			<element pattern="$fa"><reference>Segment Angle (in degrees)</reference></element>
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>
<element pattern="cube" highlight="primitive" >
	<reference><b>Create a (3d) cube.&#13;Params:</b> size, center(<i>boolean</i>)</reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="size"><reference>Cube size (number or vectors)&#13;For non-matching dimensions, use vectors: [<i>width,depth,heght</i>]</reference></element>
			
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="e.lbracket" />
		<element idref="e.rbracket" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>
<element pattern="cylinder" highlight="primitive" >
	<reference><b>Create a (3d) cylinder/cone.&#13;Params:</b> h=<i>height</i>, r=<i>Radius</i>|d=<i>diameter</i>, center(<i>boolean</i>)&#13;<b>Alt. Params: </b>h=<i>height</i>, r1=<i>bottom radius</i>|d1=<i>bottom diameter</i>, r2=<i>top radius</i>|d2=<i>top diameter</i>,center(<i>boolean</i>)&#13;<b>Special Params:</b>$fn=<i>Number segments</i> | $fs=<i>segment size</i> | $fa=<i>segment angle(degrees)</i></reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="h"><reference>Height of cylinder</reference></element>
			<element pattern="d"><reference>Diameter of cylinder&#13;For a cone, use <b>d1</b> &amp; <b>d2</b> instead</reference></element>
			<element pattern="r"><reference>Raduis of cylinder&#13;For a cone, use <b>r1</b> &amp; <b>r2</b> instead</reference></element>
			<element pattern="d1"><reference>Bottom Diameter of cylinder (use with <b>d2</b> or <b>r2</b>)</reference></element>
			<element pattern="d2"><reference>Top Diameter of cylinder (use with <b>d1</b> or <b>r1</b>)</reference></element>
			<element pattern="r1"><reference>Bottom Radius of cylinder (use with <b>d2</b> or <b>r2</b>)</reference></element>
			<element pattern="r2"><reference>Top Radius of cylinder (use with <b>d1</b> or <b>r1</b>)</reference></element>
			
		</group>
		<group highlight="special-variable">
			<autocomplete enable="1" />
			<element pattern="$fn"><reference>Number of segments</reference></element>
			<element pattern="$fs"><reference>Segment size (in default units)</reference></element>
			<element pattern="$fa"><reference>Segment Angle (in degrees)</reference></element>
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="e.lbracket" />
		<element idref="e.rbracket" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>

<element pattern="polyhedron" highlight="primitive" >
	<reference>Create a (3d) polyhedron (generic solid).&#13;Params: points=[[<i>x1,y1,z1</i>],[<i>x2,y2,z2</i>],...], faces=[[<i>point1,point2,point3</i>],[<i>point1,point2,point4</i>],...], convexity=<i>integer (for preview mode only - see manual)</i></reference>
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
		<group highlight="attribute">
			<autocomplete enable="1" />
			<element idref="center" />
			<element pattern="points"><reference>Vector of 3d points or vertices. Each point is in turn a vector, [<i>x,y,z</i>], of its coordinates.</reference></element>
			<element pattern="faces"><reference>Vector of faces which collectively enclose the solid. Each face is a vector containing the indices (0 based) of 3 or more points from the points vector.</reference></element>
			<element id="convexity" pattern="convexity"><reference>Integer. The convexity parameter specifies the maximum number of faces a ray intersecting the object might penetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode. It has no effect on the polyhedron rendering. For display problems, setting it to 10 should work fine for most cases. Default 1</reference></element>
			
		</group>
		<element idref="num"  />
		<element idref="dec" />
		<element idref="string" />
		<element idref="e.lbracket" />
		<element idref="e.rbracket" />
		<element idref="l.paren" />
		<element idref="r.paren" />
		<!-- Import math keywords -->
		<element idref="abs" />
		<element idref="acos" />
		<element idref="asin" />
		<element idref="atan" />
		<element idref="atan2" />
		<element idref="ceil" />
		<element idref="cos" />
		<element idref="exp" />
		<element idref="floor" />
		<element idref="ln" />
		<element idref="log" />
		<element idref="sqrt" />
		<element idref="tan" />
		<element idref="sin" />
		<element idref="sign" />
		<element idref="round" />
		<element idref="rands" />
		<element idref="pow" />
		<element idref="min" />
		<element idref="max" />
		<element idref="str" />
		<element idref="len" />
		<element idref="concat" />
		<element idref="chr" />
		<element idref="search" />
		<element idref="version" />
		<element idref="version_num" />
		<element idref="norm" />
		<element idref="cross" />
		<element idref="parent_module" />
	</context>
</element>
</group>
<!-- Builtins -->
<group  highlight="keyword">
	<element pattern="if">
		<autocomplete enable="1" append="()" backup_cursor="1" />
		<reference>Performs a test to determine if the actions in a sub scope should be performed or not. Can be chained by following with <i>else</i> or <i>else if</i></reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="else">
		<autocomplete enable="1" />
		<reference>Used after if. The actions in this sub scope will be performed when the <i>if</i> is false.</reference>
	</element>
	<element pattern="for">
		<autocomplete enable="1" append="()" backup_cursor="1" />
		<reference>Evaluate each value in a range or vector, applying it to the following Action(s). Shapes are joined with implicit union. See also intersection_for&#13;Usage examples: <i>for(i=[start:increment:end]) i will be set to start value, incremented each cycle until i > end.</i>&#13;<i>for(i=[vectors])</i> i will be set to each value in turn.&#13;<i>for(i=[start:inc:end],j=[start:inc:end])</i> i, j will each be incremented.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="intersection_for">
		<autocomplete enable="1" append="()" backup_cursor="1" />
		<reference>Works same as for, but joins with intersection instead of union.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="lookup">
		<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
		<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
		<reference>Look up value in table, and linearly interpolate if there's no exact match. The first argument is the value to look up. The second is the lookup table -- a vector of key-value pairs.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="echo">
		<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
		<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
		<reference>This function prints the contents to the compilation window (aka Console). Useful for debugging code. Also see the String function <i>str()</i>.</reference>
	</element>
	<element pattern="let">
		<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
		<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
		<reference>Sequential assignment of variables inside an expression. The following expression is evaluated in context of the let assignments and can use the variables. This is mainly useful to make complicated expressions more readable by assigning interim results to variables.</reference>
	</element>
</group>
<!-- Special Variables -->
<group  highlight="special-variable">
	<autocomplete enable="1" />
	<!-- Circle segments -->
	<element pattern="$fn">
		<reference>Number of segments</reference>
	</element>
	<element pattern="$fs">
		<reference>Segment size (in default units)</reference>
	</element>
	<element pattern="$fa">
		<reference>Segment Angle (in degrees)</reference>
	</element>
	<!-- Other -->
	<element pattern="$t">
		<reference>Time variable in animation</reference>
	</element>
	<element pattern="$vpr">
		<reference><b>$vpr, $vpt, $vpd</b> contain the current viewport rotation and translation and camera distance - at the time of doing the rendering.
Moving the viewport does not update them. During an animation they are updated for each frame.&#13;
<i>$vpr</i> shows rotation&#13;
<i>$vpt</i> shows translation (i.e. won't be affected by rotate and zoom)&#13;
<i>$vpd</i> shows the camera distance&#13;
      </reference>
	</element>
	<element pattern="$vpt">
		<reference><b>$vpr, $vpt, $vpd</b> contain the current viewport rotation and translation and camera distance - at the time of doing the rendering.
Moving the viewport does not update them. During an animation they are updated for each frame.&#13;
<i>$vpr</i> shows rotation&#13;
<i>$vpt</i> shows translation (i.e. won't be affected by rotate and zoom)&#13;
<i>$vpd</i> shows the camera distance&#13;</reference>
	</element>
	<element pattern="$vpd">
		<reference><b>$vpr, $vpt, $vpd</b> contain the current viewport rotation and translation and camera distance - at the time of doing the rendering.
Moving the viewport does not update them. During an animation they are updated for each frame.&#13;
<i>$vpr</i> shows rotation&#13;
<i>$vpt</i> shows translation (i.e. won't be affected by rotate and zoom)&#13;
<i>$vpd</i> shows the camera distance&#13;</reference>
	</element>
	<element pattern="$children">
		<reference>The total number of children in the module instance. Individual children are accesssed by calling <b>children(</b><i>index</i><b>)</b></reference>
	</element>
</group>

<group  highlight="transform">
	<autocomplete class="append_braces" append="() {}" backup_cursor="4" />
	<autocomplete notclass="append_braces" append="()" backup_cursor="1" />
<!-- Transforms -->
	<element pattern="translate">
		<reference>Translates (moves) its child elements along the specified vector. The parameter is a vector.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="rotate">
		<reference>Rotates its child 'a' degrees about the axis of the coordinate system or around an arbitrary axis.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="scale">
		<reference>Scales its child elements using the specified vector.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="resize">
		<reference>Modifies the size of the child object to match the given x,y, and z.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element pattern="auto" highlight="attribute">
				<reference>True or false. If set to true, it will auto-scale any 0-dimensions to match</reference>
				<autocomplete enable="1" />
			</element>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="mirror">
		<reference>Mirrors the child element on a plane through the origin. The argument to mirror() is the normal vector of a plane intersecting the origin through which to mirror the object. </reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	</element>
	<element pattern="offset">
		<reference>Offset allows moving 2D outlines outward or inward by a given amount. Parameters: r | delta, chamfer</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<group highlight="attribute">
				<element pattern="r">
					<reference>Offset amount, with radius.&#13;If positive, offsets outside and rounds outside corners.&#13;If negative, offsets inside and rounds inside corners.</reference>
					<autocomplete enable="1" />
				</element>
				<element pattern="delta">
					<reference>Offset amount. See also <b>r</b> (offset with radius)&#13;If positive, offsets outside.&#13;If negative, offsets inside.</reference>
					<autocomplete enable="1" />
				</element>
				<element pattern="chamfer">
					<reference>Boolean. (default false) When using the delta parameter, this flag defines if edges should be chamfered (cut off with a straight line) or not (extended to their intersection).</reference>
					<autocomplete enable="1" />
					<context symbols=" \=),">
						<element pattern="true" highlight="boolean" ends_context="1"><autocomplete enable="1" /></element>
						<element pattern="false" highlight="boolean" ends_context="1"><autocomplete enable="1" /></element>
					</context>
				</element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
	<element pattern="multimatrix">
		<reference>Multiplies the geometry of all child elements with the given 4x4 transformation matrix.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element pattern="m" highlight="attribute">
				<reference>Matrix of 4 x 4 vectors. This is a breakdown of what you can do with the independent elements in the matrix (for the first three rows):&#13;
<i>[Scale X]	[Scale X sheared along Y]	[Scale X sheared along Z]	[Translate X]&#13;
[Scale Y sheared along X]	[Scale Y]	[Scale Y sheared along Z]	[Translate Y]&#13;
[Scale Z sheared along X]	[Scale Z sheared along Y]	[Scale Z]	[Translate Z]</i>&#13;
The fourth row is used in 3D environments to define a view of the object. It is not used in OpenSCAD and should be [0,0,0,1] 
				</reference>
				<autocomplete enable="1" />
			</element>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
	<element pattern="color">
		<reference>Displays the child elements using the specified RGB color + alpha value. This is only used for the F5 preview as CGAL and STL (F6) do not currently support color. The alpha value will default to 1.0 (opaque) if not specified. </reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<group highlight="attribute">
				<element pattern="c">
					<reference>Color parameter. Can be a colorname, or vector of r,g,b,[a] as floating point (0-1).</reference>
					<autocomplete enable="1" />
				</element>
				<element pattern="alpha">
					<reference>Alpha transparency.</reference>
					<autocomplete enable="1" />
				</element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
	<element pattern="linear_extrude">
		<reference>Linear Extrusion is a modeling operation that takes a 2D polygon as input and extends it in the third dimension. This way a 3D shape is created. Keep in mind that extrusion is always performed from XY plane to the height indicate along Z axis; so if you rotate or apply other transformations before extrusion, the extrusion is applied to the projection of the 2D polygon to the XY plane.</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<group highlight="attribute">
				<element pattern="height">
					<reference>Z axis height after extrusion. Must be positive.</reference>
					<autocomplete enable="1" />
				</element>
				<element idref="center" />
				<element pattern="convexity">
					<reference></reference>
					<autocomplete enable="1" />
				</element>
				<element pattern="twist">
					<reference>Twist is the number of degrees of through which the shape is extruded. Setting the parameter twist = 360 will extrude through one revolution. The twist direction follows the left hand rule.</reference>
					<autocomplete enable="1" />
				</element>
				<element pattern="slices">
					<reference>Defines the number of intermediate points along the Z axis of the extrusion. Its default increases with the value of twist.&#13; Alternatively can use <b>$fn</b>, <b>$fs</b> or <b>$fa</b>.</reference>
					<autocomplete enable="1" />
				</element>
				<element pattern="scale">
					<reference>Scales the 2D shape by this value over the height of the extrusion. Scale can be a scalar or a vector. If a vector, the first number is x scale, second is y scale.</reference>
					<autocomplete enable="1" />
				</element>
			</group>
			<group highlight="special-variable">
				<autocomplete enable="1" />
				<element pattern="$fn"><reference>Number of segments</reference></element>
				<element pattern="$fs"><reference>Segment size (in default units)</reference></element>
				<element pattern="$fa"><reference>Segment Angle (in degrees)</reference></element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
	<element pattern="rotate_extrude">
		<reference>Rotational extrusion spins a 2D shape around the Z-axis to form a solid which has rotational symmetry. One way to think of this operation is to imagine a Potter's wheel placed on the X-Y plane with its axis of rotation pointing up towards +Z. Then place the to-be-made object on this virtual Potter's wheel (possibly extended down below the X-Y plane towards -Z, take the cross-section of this object on the X-Z plane but keep only the right half (X >= 0). That is the 2D shape that need to be fed to rotate_extrude() as the child in order to generate this solid. </reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<group highlight="attribute">
				<element pattern="angle">
					<reference>The number of degrees to sweep, starting at the positive X axis. Default 360.&#13;The direction of the sweep follows the Right Hand Rule, hence a negative angle will sweep clockwise.</reference>
					<autocomplete enable="1" />
				</element>
				<element idref="convexity" />
			</group>
			<group highlight="special-variable">
				<autocomplete enable="1" />
				<element pattern="$fn"><reference>Number of segments</reference></element>
				<element pattern="$fs"><reference>Segment size (in default units)</reference></element>
				<element pattern="$fa"><reference>Segment Angle (in degrees)</reference></element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
	<element pattern="projection">
		<reference>Using this function, you can create 2d drawings from 3d models, and export them to the dxf format. It works by projecting a 3D model to the (x,y) plane, with z at 0. If <i>cut</i>=true, only points with z=0 will be considered (effectively cutting the object), with <i>cut</i>=false(the default), points above and below the plane will be considered as well (creating a proper projection). </reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<group highlight="attribute">
				<element pattern="cut">
					<reference> If true, only points with z=0 will be considered (effectively cutting the object)&#13;If false(the default), points above and below the plane will be considered as well (creating a proper projection)</reference>
					<autocomplete enable="1" />
					<context symbols=" \=),">
						<element pattern="true" highlight="boolean" ends_context="1"><autocomplete enable="1" /></element>
						<element pattern="false" highlight="boolean" ends_context="1"><autocomplete enable="1" /></element>
					</context>
				</element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
	<element pattern="children">
		<autocomplete append="()" backup_cursor="1" />
		<reference>Use of children() allows modules to act as operators applied to any or all of the objects within this module instantiation.&#13;
Objects are indexed via integers from 0 to $children-1. OpenSCAD sets $children to the total number of objects within the scope. Objects grouped into a sub scope are treated as one child.&#13;
If called without a parameter, returns all children. Also can be called with the index of the desired child. 
		</reference>
		<context symbols="([],\=&#10;&#13;:\*\+\-\/ )">
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
			<!-- Import math keywords -->
			<element idref="abs" />
			<element idref="acos" />
			<element idref="asin" />
			<element idref="atan" />
			<element idref="atan2" />
			<element idref="ceil" />
			<element idref="cos" />
			<element idref="exp" />
			<element idref="floor" />
			<element idref="ln" />
			<element idref="log" />
			<element idref="sqrt" />
			<element idref="tan" />
			<element idref="sin" />
			<element idref="sign" />
			<element idref="round" />
			<element idref="rands" />
			<element idref="pow" />
			<element idref="min" />
			<element idref="max" />
			<element idref="str" />
			<element idref="len" />
			<element idref="concat" />
			<element idref="chr" />
			<element idref="search" />
			<element idref="version" />
			<element idref="version_num" />
			<element idref="norm" />
			<element idref="cross" />
			<element idref="parent_module" />
		</context>
	
	</element>
</group>
<group highlight="join">
	<autocomplete class="append_braces" append="() {}" backup_cursor="1" />
	<autocomplete notclass="append_braces" append="()" />
	
	<element pattern="hull">
		<reference>Displays the convex hull of child nodes. Basically this connects the outermost points of all its children.</reference>
	</element>
	<element pattern="minkowski">
		<reference>Displays the minkowski sum of child nodes. Think of it as translating the second object to the corners of the first, and performing a hull.</reference>
	</element>
</group>

<group highlight="definition">
	<autocomplete enable="1" append=" " />
	<element pattern="function" identifier_mode="1" identifier_jump="1" identifier_autocomp="1">
		<reference>Functions operate on values to calculate and return new values. See also module.&#13;<i>function name(parameters) = return_value;</i></reference>
	</element> 
	<element pattern="module" identifier_mode="1" identifier_jump="1" identifier_autocomp="1">
		<reference>Modules can be used to define objects or, using children(), define operators. Once defined, modules are temporarily added to the language.&#13;<i>module name(parameters) { actions }</i></reference>
	</element>
</group>

<group highlight="import">
	<autocomplete enable="1" append=" &lt;&gt;;" backup_cursor="2" />
	<element pattern="include">
		<reference>Include the specified file.&#13;<i>include &lt;file.scad&gt;</i>&#13;Acts as if the contents of the included file were written in the including file.&#13;See also <i>use</i></reference>
	</element>
	<element pattern="use">
		<reference>Include the specified file.&#13;<i>include &lt;file.scad&gt;</i>&#13;Imports modules and functions, but does not execute any commands other than those definitions.&#13;See also <i>include</i></reference>
	</element>
</group>

<group highlight="import">
	<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
	<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
	<element pattern="import">
		<reference>Imports a DXF, OFF or STL file for use in the current OpenSCAD model. The file extension is used to determine which type. Use <i>surface</i> to import png.&#13;<b>Parameters: </b> file, convexity, layer</reference>
		<context symbols="([],\=&#10;&#13;: &#34;)">
			<group highlight="attribute">
				<autocomplete enable="1" />
				<element idref="center" />
				<element pattern="file"><reference>String containing the path to the STL, OFF or DXF file.</reference></element>
				<element pattern="layer"><reference>For DXF import only, specify a specific layer to import. Optional.</reference></element>
				<element pattern="convexity"><reference>Integer. The convexity parameter specifies the maximum number of front sides (back sides) a ray intersecting the object might penetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode and has no effect on the final rendering.</reference></element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
		</context>
	</element>
	<element pattern="surface">
		<autocomplete class="append_semicolon" append="();" backup_cursor="2" />
		<autocomplete notclass="append_semicolon" append="()" backup_cursor="1" />
		<reference>Reads Heightmap information from text or image files. Currently only supports PNG.&#13;<b>Parameters: </b> file, center, invert, convexity</reference>
		<context symbols="([],\=&#10;&#13;: &#34;)">
			<group highlight="attribute">
				<autocomplete enable="1" />
				<element idref="center" />
				<element pattern="file"><reference>The path to the file containing the heightmap data.</reference></element>
				<element pattern="invert"><reference> Inverts how the color values of imported images are translated into height values. This has no effect when importing text data files. Defaults to false.</reference></element>
				<element pattern="convexity"><reference>Integer. The convexity parameter specifies the maximum number of front sides (back sides) a ray intersecting the object might penetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode and has no effect on the final rendering.</reference></element>
			</group>
			<element idref="num"  />
			<element idref="dec" />
			<element idref="string" />
			<element idref="e.lbracket" />
			<element idref="e.rbracket" />
			<element idref="l.paren" />
			<element idref="r.paren" />
		</context>
	</element>
</group>

<group highlight="join">
	<autocomplete class="append_braces" append="() {}" backup_cursor="1" />
	<autocomplete notclass="append_braces" append="()" />
<!-- joins -->
	<element pattern="difference">
		<reference>Subtracts the 2nd (and all further) child nodes from the first one (logical and not).&#13;
May be used with either 2D or 3D objects, but don't mix them.
		</reference>
	</element>
	<element pattern="union">
		<reference>Creates a union of all its child nodes. This is the sum of all children (logical or).&#13;
May be used with either 2D or 3D objects, but don't mix them.
		</reference>
	</element>
	<element pattern="intersection">
		<reference>Creates the intersection of all child nodes. This keeps the overlapping portion (logical and).&#13;
Only the area which is common or shared by all children is retained.&#13;
May be used with either 2D or 3D objects, but don't mix them.
		</reference>
	</element>
	<element pattern="render">
		<reference>Forces the generation of a mesh even in preview mode. Useful when the boolean operations become too slow to track. </reference>
	</element>
</group>

<element id="pod" pattern="=[a-zA-Z][a-zA-Z0-9 _]*[&#10;&#13;]" is_regex="1" starts_block="1" mayfold="1" highlight="comment" />
<element pattern="=cut" ends_block="1" blockstartelement="pod" highlight="comment" />

<element pattern="//[^&#10;&#13;]*" is_regex="1" highlight="comment" />
<element pattern="#[^&#10;&#13;]*" is_regex="1" highlight="highlight"><reference>Highlight in preview</reference></element>
<element pattern="[&#13;]+[&#32;]*\*[^&#10;&#13;]*" is_regex="1" highlight="disable"><reference>Disable in preview/render</reference></element>
<element pattern="[&#9;]+[&#32;]*\*[^&#10;&#13;]*" is_regex="1" highlight="disable"><reference>Disable in preview/render</reference></element>
<element pattern="[&#10;]+[&#32;]*\*[^&#10;&#13;]*" is_regex="1" highlight="disable"><reference>Disable in preview/render</reference></element>
<element pattern="[&#9;&#10;&#13;]+[&#32;]*![^&#10;&#13;]*" is_regex="1" highlight="only"><reference>Render only this</reference></element>
<element pattern="%[^&#10;&#13;]*" is_regex="1" highlight="transparent"><reference>Transparent in preview</reference></element>

</context>
</definition>
</bflang>
